(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["vuejs"] = factory();
	else
		root["vuejs"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fae3");
/******/ })
/************************************************************************/
/******/ ({

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "f2ae":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var polyfill = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	factory();
}(commonjsGlobal, (function () { 'use strict';

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

function allSettled(arr) {
  var P = this;
  return new P(function(resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(
        new TypeError(
          typeof arr +
            ' ' +
            arr +
            ' is not iterable(cannot read property Symbol(Symbol.iterator))'
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(
            val,
            function(val) {
              res(i, val);
            },
            function(e) {
              args[i] = { status: 'rejected', reason: e };
              if (--remaining === 0) {
                resolve(args);
              }
            }
          );
          return;
        }
      }
      args[i] = { status: 'fulfilled', value: val };
      if (--remaining === 0) {
        resolve(args);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = finallyConstructor;

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.allSettled = allSettled;

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = (function() {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof commonjsGlobal !== 'undefined') {
    return commonjsGlobal;
  }
  throw new Error('unable to locate global object');
})();

// Expose the polyfill if Promise is undefined or set to a
// non-function value. The latter can be due to a named HTMLElement
// being exposed by browsers for legacy reasons.
// https://github.com/taylorhakes/promise-polyfill/issues/114
if (typeof globalNS['Promise'] !== 'function') {
  globalNS['Promise'] = Promise;
} else if (!globalNS.Promise.prototype['finally']) {
  globalNS.Promise.prototype['finally'] = finallyConstructor;
} else if (!globalNS.Promise.allSettled) {
  globalNS.Promise.allSettled = allSettled;
}

})));
});

var contains = function (other) {
    if (arguments.length < 1) {
        throw new TypeError('1 argument is required');
    }
    if (typeof other !== 'object') {
        throw new TypeError('Argument 1 (”other“) to Node.contains must be an instance of Node');
    }
    var node = other;
    do {
        if (this === node) {
            return true;
        }
        if (node) {
            node = node.parentNode;
        }
    } while (node);
    return false;
};
function registerDocumentContainsPolyfill() {
    // tslint:disable-next-line
    if (typeof document === 'object' && typeof document.contains !== 'function') {
        Object.getPrototypeOf(document).contains = contains;
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};









function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}









/** @deprecated */


/** @deprecated */

var eventemitter3 = createCommonjsModule(function (module) {
'use strict';

var has = Object.prototype.hasOwnProperty
  , prefix = '~';

/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */
function Events() {}

//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
  Events.prototype = Object.create(null);

  //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //
  if (!new Events().__proto__) prefix = false;
}

/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */
function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}

/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */
function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once)
    , evt = prefix ? prefix + event : event;

  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
  else emitter._events[evt] = [emitter._events[evt], listener];

  return emitter;
}

/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */
function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();
  else delete emitter._events[evt];
}

/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */
function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */
EventEmitter.prototype.eventNames = function eventNames() {
  var names = []
    , events
    , name;

  if (this._eventsCount === 0) return names;

  for (name in (events = this._events)) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};

/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */
EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event
    , handlers = this._events[evt];

  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};

/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */
EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event
    , listeners = this._events[evt];

  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};

/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */
EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return false;

  var listeners = this._events[evt]
    , len = arguments.length
    , args
    , i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1: return listeners.fn.call(listeners.context), true;
      case 2: return listeners.fn.call(listeners.context, a1), true;
      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len -1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length
      , j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1: listeners[i].fn.call(listeners[i].context); break;
        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
        default:
          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
            args[j - 1] = arguments[j];
          }

          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};

/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};

/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};

/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;

  if (!this._events[evt]) return this;
  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (
      listeners.fn === fn &&
      (!once || listeners.once) &&
      (!context || listeners.context === context)
    ) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (
        listeners[i].fn !== fn ||
        (once && !listeners[i].once) ||
        (context && listeners[i].context !== context)
      ) {
        events.push(listeners[i]);
      }
    }

    //
    // Reset the array, or remove it completely if we have no more listeners.
    //
    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
    else clearEvent(this, evt);
  }

  return this;
};

/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */
EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
};

//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;

//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;

//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;

//
// Expose the module.
//
{
  module.exports = EventEmitter;
}
});

var eventemitter3_1 = eventemitter3.EventEmitter;

/* eslint no-void: "off" */

// Loaded ready states
var loadedStates = ['interactive', 'complete'];

// Return Promise
var whenDomReady = function whenDomReady(cb, doc) {
	return new Promise(function (resolve) {
		// Allow doc to be passed in as the lone first param
		if (cb && typeof cb !== 'function') {
			doc = cb;
			cb = null;
		}

		// Use global document if we don't have one
		doc = doc || window.document;

		// Handle DOM load
		var done = function done() {
			return resolve(void (cb && setTimeout(cb)));
		};

		// Resolve now if DOM has already loaded
		// Otherwise wait for DOMContentLoaded
		if (loadedStates.indexOf(doc.readyState) !== -1) {
			done();
		} else {
			doc.addEventListener('DOMContentLoaded', done);
		}
	});
};

// Promise chain helper
whenDomReady.resume = function (doc) {
	return function (val) {
		return whenDomReady(doc).then(function () {
			return val;
		});
	};
};

var containers = []; // will store container HTMLElement references
var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

function insertCss(css, options) {
    options = options || {};

    if (css === undefined) {
        throw new Error(usage);
    }

    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);

    // first time we see this container, create the necessary entries
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }

    // try to get the correponding container + position styleElement, create it otherwise
    var styleElement;

    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();

        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }

    // strip potential UTF-8 BOM if css was read from a file
    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

    // actually add the stylesheet
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css;
    } else {
        styleElement.textContent += css;
    }

    return styleElement;
}

function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}

var insertCss_1 = insertCss;
var insertCss_2 = insertCss;

insertCss_1.insertCss = insertCss_2;

var elementClass = function(opts) {
  return new ElementClass(opts)
};

function indexOf(arr, prop) {
  if (arr.indexOf) return arr.indexOf(prop)
  for (var i = 0, len = arr.length; i < len; i++)
    if (arr[i] === prop) return i
  return -1
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this;
  if (!opts) opts = {};

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts};

  this.opts = opts;
  this.el = opts.el || document.body;
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el);
}

ElementClass.prototype.add = function(className) {
  var el = this.el;
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ');
  if (indexOf(classes, className) > -1) return classes
  classes.push(className);
  el.className = classes.join(' ');
  return classes
};

ElementClass.prototype.remove = function(className) {
  var el = this.el;
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ');
  var idx = indexOf(classes, className);
  if (idx > -1) classes.splice(idx, 1);
  el.className = classes.join(' ');
  return classes
};

ElementClass.prototype.has = function(className) {
  var el = this.el;
  if (!el) return
  var classes = el.className.split(' ');
  return indexOf(classes, className) > -1
};

ElementClass.prototype.toggle = function(className) {
  var el = this.el;
  if (!el) return
  if (this.has(className)) this.remove(className);
  else this.add(className);
};

var lib = createCommonjsModule(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ERR_IFRAME_ALREADY_ATTACHED_TO_DOM = exports.ERR_NOT_IN_IFRAME = exports.ERR_CONNECTION_TIMEOUT = exports.ERR_CONNECTION_DESTROYED = void 0;
var HANDSHAKE = 'handshake';
var HANDSHAKE_REPLY = 'handshake-reply';
var CALL = 'call';
var REPLY = 'reply';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var MESSAGE = 'message';
var DATA_CLONE_ERROR = 'DataCloneError';
var ERR_CONNECTION_DESTROYED = 'ConnectionDestroyed';
exports.ERR_CONNECTION_DESTROYED = ERR_CONNECTION_DESTROYED;
var ERR_CONNECTION_TIMEOUT = 'ConnectionTimeout';
exports.ERR_CONNECTION_TIMEOUT = ERR_CONNECTION_TIMEOUT;
var ERR_NOT_IN_IFRAME = 'NotInIframe';
exports.ERR_NOT_IN_IFRAME = ERR_NOT_IN_IFRAME;
var ERR_IFRAME_ALREADY_ATTACHED_TO_DOM = 'IframeAlreadyAttachedToDom';
exports.ERR_IFRAME_ALREADY_ATTACHED_TO_DOM = ERR_IFRAME_ALREADY_ATTACHED_TO_DOM;
var CHECK_IFRAME_IN_DOC_INTERVAL = 60000;
var DEFAULT_PORTS = {
  'http:': '80',
  'https:': '443'
};
var URL_REGEX = /^(https?:|file:)?\/\/([^/:]+)?(:(\d+))?/;
var Penpal = {
  ERR_CONNECTION_DESTROYED: ERR_CONNECTION_DESTROYED,
  ERR_CONNECTION_TIMEOUT: ERR_CONNECTION_TIMEOUT,
  ERR_NOT_IN_IFRAME: ERR_NOT_IN_IFRAME,
  ERR_IFRAME_ALREADY_ATTACHED_TO_DOM: ERR_IFRAME_ALREADY_ATTACHED_TO_DOM,

  /**
   * Promise implementation.
   * @type {Constructor}
   */
  Promise: function () {
    try {
      return window ? window.Promise : null;
    } catch (e) {
      return null;
    }
  }(),

  /**
   * Whether debug messages should be logged.
   * @type {boolean}
   */
  debug: false
};
/**
 * @return {number} A unique ID (not universally unique)
 */

var generateId = function () {
  var id = 0;
  return function () {
    return ++id;
  };
}();
/**
 * Logs a message.
 * @param {...*} args One or more items to log
 */


var log = function log() {
  if (Penpal.debug) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_console = console).log.apply(_console, ['[Penpal]'].concat(args)); // eslint-disable-line no-console

  }
};
/**
 * Converts a URL into an origin.
 * @param {string} url
 * @return {string} The URL's origin
 */


var getOriginFromUrl = function getOriginFromUrl(url) {
  var location = document.location;
  var regexResult = URL_REGEX.exec(url);
  var protocol;
  var hostname;
  var port;

  if (regexResult) {
    // It's an absolute URL. Use the parsed info.
    // regexResult[1] will be undefined if the URL starts with //
    protocol = regexResult[1] ? regexResult[1] : location.protocol;
    hostname = regexResult[2];
    port = regexResult[4];
  } else {
    // It's a relative path. Use the current location's info.
    protocol = location.protocol;
    hostname = location.hostname;
    port = location.port;
  } // If the protocol is file, the origin is "null"
  // The origin of a document with file protocol is an opaque origin
  // and its serialization "null" [1]
  // [1] https://html.spec.whatwg.org/multipage/origin.html#origin


  if (protocol === "file:") {
    return "null";
  } // If the port is the default for the protocol, we don't want to add it to the origin string
  // or it won't match the message's event.origin.


  var portSuffix = port && port !== DEFAULT_PORTS[protocol] ? ":".concat(port) : '';
  return "".concat(protocol, "//").concat(hostname).concat(portSuffix);
};
/**
 * A simplified promise class only used internally for when destroy() is called. This is
 * used to destroy connections synchronously while promises typically resolve asynchronously.
 *
 * @param {Function} executor
 * @returns {Object}
 * @constructor
 */


var DestructionPromise = function DestructionPromise(executor) {
  var handlers = [];
  executor(function () {
    handlers.forEach(function (handler) {
      handler();
    });
  });
  return {
    then: function then(handler) {
      handlers.push(handler);
    }
  };
};
/**
 * Converts an error object into a plain object.
 * @param {Error} Error object.
 * @returns {Object}
 */


var serializeError = function serializeError(_ref) {
  var name = _ref.name,
      message = _ref.message,
      stack = _ref.stack;
  return {
    name: name,
    message: message,
    stack: stack
  };
};
/**
 * Converts a plain object into an error object.
 * @param {Object} Object with error properties.
 * @returns {Error}
 */


var deserializeError = function deserializeError(obj) {
  var deserializedError = new Error();
  Object.keys(obj).forEach(function (key) {
    return deserializedError[key] = obj[key];
  });
  return deserializedError;
};
/**
 * Augments an object with methods that match those defined by the remote. When these methods are
 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
 * executed, and the method's return value will be returned via a message.
 * @param {Object} callSender Sender object that should be augmented with methods.
 * @param {Object} info Information about the local and remote windows.
 * @param {Array} methodNames Names of methods available to be called on the remote.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Object} The call sender object with methods that may be called.
 */


var connectCallSender = function connectCallSender(callSender, info, methodNames, destroy, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;
  var destroyed = false;
  log("".concat(localName, ": Connecting call sender"));

  var createMethodProxy = function createMethodProxy(methodName) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log("".concat(localName, ": Sending ").concat(methodName, "() call")); // This handles the case where the iframe has been removed from the DOM
      // (and therefore its window closed), the consumer has not yet
      // called destroy(), and the user calls a method exposed by
      // the remote. We detect the iframe has been removed and force
      // a destroy() immediately so that the consumer sees the error saying
      // the connection has been destroyed.

      if (remote.closed) {
        destroy();
      }

      if (destroyed) {
        var error = new Error("Unable to send ".concat(methodName, "() call due ") + "to destroyed connection");
        error.code = ERR_CONNECTION_DESTROYED;
        throw error;
      }

      return new Penpal.Promise(function (resolve, reject) {
        var id = generateId();

        var handleMessageEvent = function handleMessageEvent(event) {
          if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id) {
            log("".concat(localName, ": Received ").concat(methodName, "() reply"));
            local.removeEventListener(MESSAGE, handleMessageEvent);
            var returnValue = event.data.returnValue;

            if (event.data.returnValueIsError) {
              returnValue = deserializeError(returnValue);
            }

            (event.data.resolution === FULFILLED ? resolve : reject)(returnValue);
          }
        };

        local.addEventListener(MESSAGE, handleMessageEvent);
        remote.postMessage({
          penpal: CALL,
          id: id,
          methodName: methodName,
          args: args
        }, remoteOrigin);
      });
    };
  };

  destructionPromise.then(function () {
    destroyed = true;
  });
  methodNames.reduce(function (api, methodName) {
    api[methodName] = createMethodProxy(methodName);
    return api;
  }, callSender);
};
/**
 * Listens for "call" messages coming from the remote, executes the corresponding method, and
 * responds with the return value.
 * @param {Object} info Information about the local and remote windows.
 * @param {Object} methods The keys are the names of the methods that can be called by the remote
 * while the values are the method functions.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Function} A function that may be called to disconnect the receiver.
 */


var connectCallReceiver = function connectCallReceiver(info, methods, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;
  var destroyed = false;
  log("".concat(localName, ": Connecting call receiver"));

  var handleMessageEvent = function handleMessageEvent(event) {
    if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
      var _event$data = event.data,
          methodName = _event$data.methodName,
          args = _event$data.args,
          id = _event$data.id;
      log("".concat(localName, ": Received ").concat(methodName, "() call"));

      if (methodName in methods) {
        var createPromiseHandler = function createPromiseHandler(resolution) {
          return function (returnValue) {
            log("".concat(localName, ": Sending ").concat(methodName, "() reply"));

            if (destroyed) {
              // It's possible to throw an error here, but it would need to be thrown asynchronously
              // and would only be catchable using window.onerror. This is because the consumer
              // is merely returning a value from their method and not calling any function
              // that they could wrap in a try-catch. Even if the consumer were to catch the error,
              // the value of doing so is questionable. Instead, we'll just log a message.
              log("".concat(localName, ": Unable to send ").concat(methodName, "() reply due to destroyed connection"));
              return;
            }

            var message = {
              penpal: REPLY,
              id: id,
              resolution: resolution,
              returnValue: returnValue
            };

            if (resolution === REJECTED && returnValue instanceof Error) {
              message.returnValue = serializeError(returnValue);
              message.returnValueIsError = true;
            }

            try {
              remote.postMessage(message, remoteOrigin);
            } catch (err) {
              // If a consumer attempts to send an object that's not cloneable (e.g., window),
              // we want to ensure the receiver's promise gets rejected.
              if (err.name === DATA_CLONE_ERROR) {
                remote.postMessage({
                  penpal: REPLY,
                  id: id,
                  resolution: REJECTED,
                  returnValue: serializeError(err),
                  returnValueIsError: true
                }, remoteOrigin);
              }

              throw err;
            }
          };
        };

        new Penpal.Promise(function (resolve) {
          return resolve(methods[methodName].apply(methods, args));
        }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
      }
    }
  };

  local.addEventListener(MESSAGE, handleMessageEvent);
  destructionPromise.then(function () {
    destroyed = true;
    local.removeEventListener(MESSAGE, handleMessageEvent);
  });
};
/**
 * @typedef {Object} Child
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 * @property {HTMLIframeElement} iframe The created iframe element.
 * @property {Function} destroy A method that, when called, will remove the iframe element from
 * the DOM and clean up event listeners.
 */

/**
 * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with
 * the iframe.
 * @param {Object} options
 * @param {string} options.url The URL of the webpage that should be loaded into the created iframe.
 * @param {HTMLElement} [options.appendTo] The container to which the iframe should be appended.
 * @param {Object} [options.methods={}] Methods that may be called by the iframe.
 * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait
 * for the child to respond before rejecting the connection promise.
 * @return {Child}
 */


Penpal.connectToChild = function (_ref2) {
  var url = _ref2.url,
      appendTo = _ref2.appendTo,
      iframe = _ref2.iframe,
      _ref2$methods = _ref2.methods,
      methods = _ref2$methods === void 0 ? {} : _ref2$methods,
      timeout = _ref2.timeout;

  if (iframe && iframe.parentNode) {
    var error = new Error('connectToChild() must not be called with an iframe already attached to DOM');
    error.code = ERR_IFRAME_ALREADY_ATTACHED_TO_DOM;
    throw error;
  }

  var destroy;
  var connectionDestructionPromise = new DestructionPromise(function (resolveConnectionDestructionPromise) {
    destroy = resolveConnectionDestructionPromise;
  });
  var parent = window;
  iframe = iframe || document.createElement('iframe');
  iframe.src = url;
  var childOrigin = getOriginFromUrl(url);
  var promise = new Penpal.Promise(function (resolveConnectionPromise, reject) {
    var connectionTimeoutId;

    if (timeout !== undefined) {
      connectionTimeoutId = setTimeout(function () {
        var error = new Error("Connection to child timed out after ".concat(timeout, "ms"));
        error.code = ERR_CONNECTION_TIMEOUT;
        reject(error);
        destroy();
      }, timeout);
    } // We resolve the promise with the call sender. If the child reconnects (for example, after
    // refreshing or navigating to another page that uses Penpal, we'll update the call sender
    // with methods that match the latest provided by the child.


    var callSender = {};
    var receiverMethodNames;
    var destroyCallReceiver;

    var handleMessage = function handleMessage(event) {
      var child = iframe.contentWindow;

      if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE) {
        log('Parent: Received handshake, sending reply'); // If event.origin is "null", the remote protocol is file:
        // and we must post messages with "*" as targetOrigin [1]
        // [1] https://developer.mozilla.org/fr/docs/Web/API/Window/postMessage#Utiliser_window.postMessage_dans_les_extensions

        var remoteOrigin = event.origin === "null" ? "*" : event.origin;
        event.source.postMessage({
          penpal: HANDSHAKE_REPLY,
          methodNames: Object.keys(methods)
        }, remoteOrigin);
        var info = {
          localName: 'Parent',
          local: parent,
          remote: child,
          remoteOrigin: remoteOrigin
        }; // If the child reconnected, we need to destroy the previous call receiver before setting
        // up a new one.

        if (destroyCallReceiver) {
          destroyCallReceiver();
        } // When this promise is resolved, it will destroy the call receiver (stop listening to
        // method calls from the child) and delete its methods off the call sender.


        var callReceiverDestructionPromise = new DestructionPromise(function (resolveCallReceiverDestructionPromise) {
          connectionDestructionPromise.then(resolveCallReceiverDestructionPromise);
          destroyCallReceiver = resolveCallReceiverDestructionPromise;
        });
        connectCallReceiver(info, methods, callReceiverDestructionPromise); // If the child reconnected, we need to remove the methods from the previous call receiver
        // off the sender.

        if (receiverMethodNames) {
          receiverMethodNames.forEach(function (receiverMethodName) {
            delete callSender[receiverMethodName];
          });
        }

        receiverMethodNames = event.data.methodNames;
        connectCallSender(callSender, info, receiverMethodNames, destroy, connectionDestructionPromise);
        clearTimeout(connectionTimeoutId);
        resolveConnectionPromise(callSender);
      }
    };

    parent.addEventListener(MESSAGE, handleMessage);
    log('Parent: Loading iframe');
    (appendTo || document.body).appendChild(iframe); // This is to prevent memory leaks when the iframe is removed
    // from the document and the consumer hasn't called destroy().
    // Without this, event listeners attached to the window would
    // stick around and since the event handlers have a reference
    // to the iframe in their closures, the iframe would stick around
    // too.

    var checkIframeInDocIntervalId = setInterval(function () {
      if (!document.body.contains(iframe)) {
        clearInterval(checkIframeInDocIntervalId);
        destroy();
      }
    }, CHECK_IFRAME_IN_DOC_INTERVAL);
    connectionDestructionPromise.then(function () {
      if (iframe.parentNode) {
        iframe.parentNode.removeChild(iframe);
      }

      parent.removeEventListener(MESSAGE, handleMessage);
      clearInterval(checkIframeInDocIntervalId);
      var error = new Error('Connection destroyed');
      error.code = ERR_CONNECTION_DESTROYED;
      reject(error);
    });
  });
  return {
    promise: promise,
    iframe: iframe,
    destroy: destroy
  };
};
/**
 * @typedef {Object} Parent
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 */

/**
 * Attempts to establish communication with the parent window.
 * @param {Object} options
 * @param {string} [options.parentOrigin=*] Valid parent origin used to restrict communication.
 * @param {Object} [options.methods={}] Methods that may be called by the parent window.
 * @param {Number} [options.timeout] The amount of time, in milliseconds, Penpal should wait
 * for the parent to respond before rejecting the connection promise.
 * @return {Parent}
 */


Penpal.connectToParent = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$parentOrigin = _ref3.parentOrigin,
      parentOrigin = _ref3$parentOrigin === void 0 ? '*' : _ref3$parentOrigin,
      _ref3$methods = _ref3.methods,
      methods = _ref3$methods === void 0 ? {} : _ref3$methods,
      timeout = _ref3.timeout;

  if (window === window.top) {
    var error = new Error('connectToParent() must be called within an iframe');
    error.code = ERR_NOT_IN_IFRAME;
    throw error;
  }

  var destroy;
  var connectionDestructionPromise = new DestructionPromise(function (resolveConnectionDestructionPromise) {
    destroy = resolveConnectionDestructionPromise;
  });
  var child = window;
  var parent = child.parent;
  var promise = new Penpal.Promise(function (resolveConnectionPromise, reject) {
    var connectionTimeoutId;

    if (timeout !== undefined) {
      connectionTimeoutId = setTimeout(function () {
        var error = new Error("Connection to parent timed out after ".concat(timeout, "ms"));
        error.code = ERR_CONNECTION_TIMEOUT;
        reject(error);
        destroy();
      }, timeout);
    }

    var handleMessageEvent = function handleMessageEvent(event) {
      if ((parentOrigin === '*' || parentOrigin === event.origin) && event.source === parent && event.data.penpal === HANDSHAKE_REPLY) {
        log('Child: Received handshake reply');
        child.removeEventListener(MESSAGE, handleMessageEvent);
        var info = {
          localName: 'Child',
          local: child,
          remote: parent,
          remoteOrigin: event.origin
        };
        var callSender = {};
        connectCallReceiver(info, methods, connectionDestructionPromise);
        connectCallSender(callSender, info, event.data.methodNames, destroy, connectionDestructionPromise);
        clearTimeout(connectionTimeoutId);
        resolveConnectionPromise(callSender);
      }
    };

    child.addEventListener(MESSAGE, handleMessageEvent);
    connectionDestructionPromise.then(function () {
      child.removeEventListener(MESSAGE, handleMessageEvent);
      var error = new Error('Connection destroyed');
      error.code = ERR_CONNECTION_DESTROYED;
      reject(error);
    });
    log('Child: Sending handshake');
    parent.postMessage({
      penpal: HANDSHAKE,
      methodNames: Object.keys(methods)
    }, parentOrigin);
  });
  return {
    promise: promise,
    destroy: destroy
  };
};

var _default = Penpal;
exports.default = _default;
});

var Penpal = unwrapExports(lib);

var Stats = /** @class */ (function () {
    function Stats(meta) {
        this.$meta = meta;
    }
    Object.defineProperty(Stats.prototype, "originalRows", {
        /**
         * The number of rows in the parsed data
         */
        get: function () {
            return this.$meta.count_rows;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stats.prototype, "acceptedRows", {
        /**
         * The number of rows that were submitted
         */
        get: function () {
            return this.$meta.count_rows_accepted || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stats.prototype, "originalColumns", {
        /**
         * The number of columns in the parsed data
         */
        get: function () {
            return this.$meta.count_columns || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Stats.prototype, "matchedColumns", {
        /**
         * The number of columns submitted
         */
        get: function () {
            return this.$meta.count_columns_matched || null;
        },
        enumerable: false,
        configurable: true
    });
    return Stats;
}());

var EndUser = /** @class */ (function () {
    function EndUser(meta) {
        this.$user = meta;
    }
    Object.defineProperty(EndUser.prototype, "id", {
        /**
         * The UUID referencing the user's record stored in Flatfile
         */
        get: function () {
            return this.$user.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EndUser.prototype, "userId", {
        /**
         * Your internal ID reference for this user (required)
         */
        get: function () {
            return this.$user.userId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EndUser.prototype, "name", {
        /**
         * The user's full name if you provided it
         */
        get: function () {
            return this.$user.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EndUser.prototype, "email", {
        /**
         * The user's email if you provided it
         */
        get: function () {
            return this.$user.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EndUser.prototype, "companyName", {
        /**
         * The company name the user is currently operating under
         */
        get: function () {
            return this.$user.companyName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EndUser.prototype, "companyId", {
        /**
         * The company name the user is currently operating under
         */
        get: function () {
            return this.$user.companyId;
        },
        enumerable: false,
        configurable: true
    });
    return EndUser;
}());

var UploadFile = /** @class */ (function () {
    function UploadFile(file) {
        this.$file = file;
    }
    Object.defineProperty(UploadFile.prototype, "id", {
        /**
         * A unique UUID referencing this file in the Flatfile system
         */
        get: function () {
            return this.$file.id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UploadFile.prototype, "filename", {
        /**
         * The original filename on the user's system
         */
        get: function () {
            return this.$file.filename;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UploadFile.prototype, "filesize", {
        /**
         * The size of the file in bytes
         */
        get: function () {
            return this.$file.filesize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UploadFile.prototype, "filetype", {
        /**
         * The type of file
         */
        get: function () {
            return this.$file.filetype;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(UploadFile.prototype, "url", {
        /**
         * A securely signed url giving you temporary access to download the file
         */
        get: function () {
            return this.$file.url;
        },
        enumerable: false,
        configurable: true
    });
    return UploadFile;
}());

var StreamedResults = /** @class */ (function () {
    function StreamedResults(data, meta) {
        this.$meta = meta;
        this.$data = data;
    }
    Object.defineProperty(StreamedResults.prototype, "rawOutput", {
        /**
         * The raw output from the importer including all deleted rows
         * and sequence info
         */
        get: function () {
            return this.$data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "data", {
        /**
         * An array of valid data, key-mapped to the configuration provided
         * (alias of validData)
         */
        get: function () {
            return this.validData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "validData", {
        /**
         * An array of valid data, key-mapped to the configuration provided
         */
        get: function () {
            return this.$data
                .filter(function (v) { return v.valid; })
                .filter(function (v) { return !v.deleted; })
                .map(function (v) { return v.data; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "deletedData", {
        /**
         * Rows of data the user excluded from the final results,
         * key-mapped to the configuration provided
         */
        get: function () {
            return this.$data.filter(function (v) { return v.deleted; }).map(function (v) { return v.data; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "allData", {
        /**
         * All data from the original file upload including deleted rows,
         * key-mapped to the configuration provided
         */
        get: function () {
            return this.$data.map(function (v) { return v.data; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "remainingChunks", {
        /**
         * The number of remaining chunks in the stream
         */
        get: function () {
            return Math.ceil((this.totalChunks - this.currentChunk) / this.$meta.inChunks);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "totalChunks", {
        /**
         * The total number of chunks that will have to be received before data processing is completed
         */
        get: function () {
            return Math.ceil(this.$meta.count_rows_accepted / this.$meta.inChunks);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "chunkSize", {
        /**
         * The size of chunks as configured when requesting data.
         */
        get: function () {
            return this.$meta.inChunks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "currentChunk", {
        /**
         * The current chunk by index
         */
        get: function () {
            return (this.$meta.pointer + this.chunkSize) / this.chunkSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StreamedResults.prototype, "hasMore", {
        /**
         * The current chunk by index
         */
        get: function () {
            return this.$meta.hasMore;
        },
        enumerable: false,
        configurable: true
    });
    return StreamedResults;
}());

var Results = /** @class */ (function () {
    function Results(data, meta, importer) {
        this.$meta = meta;
        this.$data = data;
        this.$importer = importer;
    }
    Object.defineProperty(Results.prototype, "rawOutput", {
        /**
         * The raw output from the importer including all deleted rows
         * and sequence info
         */
        get: function () {
            return this.blobOnly(this.$data, 'rawOutput');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "data", {
        /**
         * An array of valid data, key-mapped to the configuration provided
         * (alias of validData)
         */
        get: function () {
            return this.blobOnly(this.validData, 'data');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "validData", {
        /**
         * An array of valid data, key-mapped to the configuration provided
         */
        get: function () {
            var res = this.$data
                .filter(function (v) { return v.valid; })
                .filter(function (v) { return !v.deleted; })
                .map(function (v) { return v.data; });
            return this.blobOnly(res, 'validData');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "deletedData", {
        /**
         * Rows of data the user excluded from the final results,
         * key-mapped to the configuration provided
         */
        get: function () {
            var res = this.$data.filter(function (v) { return v.deleted; }).map(function (v) { return v.data; });
            return this.blobOnly(res, 'deletedData');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "allData", {
        /**
         * All data from the original file upload including deleted rows,
         * key-mapped to the configuration provided
         */
        get: function () {
            return this.blobOnly(this.$data.map(function (v) { return v.data; }), 'allData');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "batchId", {
        /**
         * The uuid of the batch assigned by Flatfile (use this in internal
         * references for support purposes)
         */
        get: function () {
            return this.$meta.batchID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "stats", {
        /**
         * Stats and counts about this file upload
         */
        get: function () {
            return new Stats(this.$meta);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "customer", {
        /**
         * The customer provided in setCustomer
         */
        get: function () {
            if (this.$meta.endUser) {
                return new EndUser(this.$meta.endUser);
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "originalFile", {
        /**
         * A File object of the originally uploaded file stored as an AWS url
         */
        get: function () {
            if (this.$meta.originalFile) {
                return new UploadFile(this.$meta.originalFile);
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "csvFile", {
        /**
         * Same as originalFile unless it was uploaded in xls format, in which case this is the converted csv file stored as an AWS url
         */
        get: function () {
            if (this.$meta.originalFile) {
                if (this.$meta.originalFile.filetype === 'csv') {
                    return new UploadFile(this.$meta.originalFile);
                }
                else {
                    if (this.$meta.csvFile) {
                        return new UploadFile(this.$meta.csvFile);
                    }
                }
            }
            return null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "fileName", {
        /**
         * The filename of the originally uploaded file
         */
        get: function () {
            return this.$meta.filename || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "managed", {
        /**
         * If the final upload is managed by a private endpoint or not
         */
        get: function () {
            return this.$meta.managed || false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "manual", {
        /**
         * If the data was entered manually instead of via file upload or not
         */
        get: function () {
            return this.$meta.manual;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "config", {
        /**
         * The parsed and bootstrapped config object used by this importer instance
         */
        get: function () {
            return this.$meta.config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "parsingConfig", {
        /**
         * The configuration used by the csv parser PapaParse: https://www.papaparse.com/docs#config
         */
        get: function () {
            return this.$meta.parsing_config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "skippedRows", {
        /**
         * The invalid rows that were skipped on submission
         */
        get: function () {
            return this.$meta.skipped_rows || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "headersRaw", {
        /**
         * The headers before they were matched as given in the original file
         */
        get: function () {
            return this.$meta.headers_raw || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "headersMatched", {
        /**
         * The headers after they are matched
         */
        get: function () {
            return this.$meta.headers_matched || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "customColumns", {
        /**
         * An array of any columns that were created during import
         */
        get: function () {
            return this.$meta.custom_columns;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "categoryFieldMap", {
        /**
         * A mapping of source values to target category values
         */
        get: function () {
            return this.$meta.category_field_map || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "failureReason", {
        /**
         * The reason for the failure if there was a failure
         */
        get: function () {
            return this.$meta.failure_reason || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "submittedAt", {
        /**
         * The time that the data was submitted
         */
        get: function () {
            return this.$meta.submitted_at || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "failedAt", {
        /**
         * The time that the import failed if it failed
         */
        get: function () {
            return this.$meta.failed_at || null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "createdAt", {
        /**
         * The time the data began the import, whether via file upload or manual data entry
         */
        get: function () {
            return this.$meta.created_at;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Results.prototype, "stylesheet", {
        /**
         * The stylesheet of the cells. Make sure to use `allowFormatting=true` in the config.
         */
        get: function () {
            return this.$meta.stylesheet;
        },
        enumerable: false,
        configurable: true
    });
    Results.prototype.blobOnly = function (v, method, alt) {
        if (alt === void 0) { alt = 'nextChunk()'; }
        if (this.$meta.inChunks) {
            throw new Error("\"" + method + "\" is not accessible when using \"inChunks\". Please see docs for \"" + alt + "\" instead.");
        }
        return v;
    };
    /**
     * Get the next chunk of records
     */
    Results.prototype.nextChunk = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!_this.$meta.inChunks) {
                return reject("\"nextChunk()\" is only accessible when using \"inChunks\". Please see docs for \"requestDataFromUser\".");
            }
            _this.$importer.$ready.then(function (child) {
                console.log('child.nextChunk()');
                child.nextChunk().then(function (data) {
                    console.log('nextChunk()', data);
                    resolve(data.results.length ? new StreamedResults(data.results, data.meta) : null);
                }, function (err) {
                    console.log('nextChunk(err)', err);
                });
            });
        });
    };
    return Results;
}());

var FlatfileImporter$1 = /** @class */ (function (_super) {
    __extends(FlatfileImporter, _super);
    function FlatfileImporter(apiKey, options, customer) {
        var _this = _super.call(this) || this;
        _this.$fieldHooks = [];
        _this.$stepHooks = {};
        _this.apiKey = apiKey;
        _this.options = options;
        _this.customer = customer;
        _this.uuid = _this.$generateUuid();
        _this.$ready = new FlatfileImporter.Promise(function (resolve, reject) {
            _this.$resolver = resolve;
            _this.$rejecter = reject;
        });
        whenDomReady(function () {
            _this.initialize();
        });
        return _this;
    }
    /**
     * This will by default always be `https://www.flatfile.io/importer/:key` unless you are
     * an enterprise customer that is self-hosting the application. In which case, this
     * will be the URL of your enterprise installd Flatfile importer index page
     */
    FlatfileImporter.setMountUrl = function (url) {
        this.MOUNT_URL = url;
    };
    /**
     * This allows you to opt into or out of specific versions of the Flatfile SDK
     */
    FlatfileImporter.setVersion = function (version) {
        switch (version) {
            case 1:
                this.MOUNT_URL = 'https://kiosk-lite.flatfile.io/?key=:key';
                break;
            case 2:
                this.MOUNT_URL = 'https://portal-2.flatfile.io/?key=:key';
                break;
            default:
                throw new Error(version + " is not a valid version");
        }
    };
    /**
     * Call open() to activate the importer overlay dialog.
     */
    FlatfileImporter.prototype.open = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        options = __assign(__assign({}, options), { bulkInit: true, hasRecordHook: !!this.$recordHook, hasInteractionEventCallback: !!this.$interactionEventCallback, stepHooks: Object.keys(this.$stepHooks), fieldHooks: this.$fieldHooks.map(function (v) { return v.field; }), endUser: this.customer });
        this.$ready.then(function (child) {
            elementClass(document.body).add('flatfile-active');
            var el = document.getElementById("flatfile-" + _this.uuid);
            if (el) {
                el.style.display = 'block';
            }
            child.open(options);
        });
    };
    /**
     * Use load() when you want a promise returned. This is necessary if you want to use
     * async/await for an es6 implementation
     * @deprecated
     */
    FlatfileImporter.prototype.load = function () {
        var _this = this;
        return new FlatfileImporter.Promise(function (resolve, reject) {
            _this.open();
            var cleanup = function () {
                _this.removeListener('close', loadRejectHandler);
                _this.removeListener('complete', loadResolveHandler);
            };
            function loadResolveHandler(rows) {
                resolve(rows);
                cleanup();
            }
            function loadRejectHandler(err) {
                reject(err);
                cleanup();
            }
            _this.on('close', loadRejectHandler);
            _this.on('complete', loadResolveHandler);
        });
    };
    /**
     * Use requestDataFromUser() when you want a promise returned. This is necessary if you want to use
     * async/await for an es6 implementation
     */
    FlatfileImporter.prototype.requestDataFromUser = function (options) {
        if (options === void 0) { options = {}; }
        this.open(__assign(__assign({}, options), { inChunks: options.inChunks || null, expectsExpandedResults: true }));
        return this.responsePromise();
    };
    /**
     * This will display a progress indicator inside the importer if you anticipate that handling
     * the output of the importer may take some time.
     */
    FlatfileImporter.prototype.displayLoader = function (msg) {
        this.$ready.then(function (child) {
            child.displayLoader(msg);
        });
    };
    /**
     * This will display a dialog inside of the importer with an error icon and the message you
     * pass. The user will be able to acknowledge the error and be returned to the import data
     * spreadsheet to ideally fix any issues or attempt submitting again.
     * @deprecated
     */
    FlatfileImporter.prototype.displayError = function (msg) {
        this.$ready.then(function (child) {
            child.displayError(msg);
        });
    };
    /**
     * This will display a dialog inside of the importer with an error icon and the message you
     * pass. The user will be able to acknowledge the error and be returned to the import data
     * spreadsheet to ideally fix any issues or attempt submitting again.
     *
     * @param corrections - allows user to do server-side validation and provide error / warning
     * messages or value overrides
     */
    FlatfileImporter.prototype.requestCorrectionsFromUser = function (msg, corrections) {
        this.$ready.then(function (child) {
            child.displayError(msg, corrections);
        });
        return this.responsePromise();
    };
    /**
     * This will display a dialog inside of the importer with a success icon and the message you
     * pass.
     *
     * @return Promise that will be resolved when user closes the dialog.
     */
    FlatfileImporter.prototype.displaySuccess = function (msg) {
        var _this = this;
        this.$ready.then(function (child) {
            child.displaySuccess(msg);
        });
        return new Promise(function (resolve) {
            var handleSuccess = function () {
                resolve();
                _this.removeListener('close', handleSuccess);
            };
            _this.on('close', handleSuccess);
        });
    };
    /**
     * Set the customer information for this import
     */
    FlatfileImporter.prototype.setCustomer = function (customer) {
        this.customer = customer;
    };
    /**
     * Set the language for the Portal
     */
    FlatfileImporter.prototype.setLanguage = function (lang) {
        this.$ready.then(function (child) {
            child.setLanguage(lang);
        });
    };
    FlatfileImporter.prototype.addVirtualField = function (field, options) {
        if (options === void 0) { options = {}; }
        this.$ready.then(function (child) {
            child.addVirtualField({ field: field, options: options });
        });
    };
    /**
     * Set the customer information for this import
     */
    FlatfileImporter.prototype.registerRecordHook = function (callback) {
        this.$recordHook = callback;
    };
    FlatfileImporter.prototype.registerNetworkErrorCallback = function (callback) {
        this.$networkErrorCallback = callback;
    };
    FlatfileImporter.prototype.registerBeforeFetchCallback = function (callback) {
        this.$beforeFetchCallback = callback;
    };
    FlatfileImporter.prototype.registerInteractionEventCallback = function (callback) {
        this.$interactionEventCallback = callback;
    };
    FlatfileImporter.prototype.registerFieldHook = function (field, cb) {
        this.$fieldHooks.push({ field: field, cb: cb });
    };
    FlatfileImporter.prototype.registerStepHook = function (step, callback) {
        this.$stepHooks[step] = callback;
    };
    /**
     * Call close() from the parent window in order to hide the importer. You can do this after
     * handling the import callback so your users don't have to click the confirmation button
     */
    FlatfileImporter.prototype.close = function () {
        this.$ready.then(function (child) {
            child.close();
        });
    };
    FlatfileImporter.prototype.handleClose = function () {
        elementClass(document.body).remove('flatfile-active');
        var el = document.getElementById("flatfile-" + this.uuid);
        if (el) {
            el.style.display = 'none';
        }
    };
    FlatfileImporter.prototype.initialize = function () {
        var _this = this;
        insertCss_1("\n      .flatfile-component {\n        position: fixed;\n        top: 0;\n        bottom: 0;\n        right: 0;\n        left: 0;\n        display: none;\n        z-index: 100000;\n      }\n      .flatfile-component iframe {\n        width: 100%;\n        height: 100%;\n        position: absolute;\n        border-width: 0;\n      }\n      body.flatfile-active {\n        overflow: hidden;\n        overscroll-behavior-x: none;\n      }\n    ");
        document.body.insertAdjacentHTML('beforeend', "<div id=\"flatfile-" + this.uuid + "\" class=\"flatfile-component\"></div>");
        this.handshake = Penpal.connectToChild({
            appendTo: document.getElementById("flatfile-" + this.uuid) || undefined,
            url: FlatfileImporter.MOUNT_URL.replace(':key', this.apiKey),
            methods: {
                results: function (data) {
                    _this.emit('results', data.results, data.meta);
                },
                complete: function (data) {
                    _this.emit('complete', data.rows, data.meta);
                },
                close: function () {
                    _this.emit('close');
                    _this.handleClose();
                },
                networkErrorCallback: function (error) {
                    return _this.$networkErrorCallback ? _this.$networkErrorCallback(error) : undefined;
                },
                beforeFetchCallback: function (req) {
                    return _this.$beforeFetchCallback ? _this.$beforeFetchCallback(req) : undefined;
                },
                interactionEventCallback: function (req) {
                    return _this.$interactionEventCallback ? _this.$interactionEventCallback(req) : undefined;
                },
                dataHookCallback: function (row, index, mode) {
                    try {
                        return _this.$recordHook ? _this.$recordHook(row, index, mode) : undefined;
                    }
                    catch (_a) {
                        var message = _a.message, stack = _a.stack;
                        console.error("Flatfile Record Hook Error on row " + index + ":\n  " + stack, { row: row, mode: mode });
                        return {};
                    }
                },
                bulkHookCallback: function (rows, mode) {
                    try {
                        return _this.$recordHook
                            ? Promise.all(rows.map(function (_a) {
                                var row = _a[0], index = _a[1];
                                try {
                                    return _this.$recordHook(row, index, mode);
                                }
                                catch (e) {
                                    e.row = row;
                                    e.index = index;
                                    throw e;
                                }
                            }))
                            : undefined;
                    }
                    catch (_a) {
                        var stack = _a.stack, row = _a.row, index = _a.index;
                        console.error("Flatfile Record Hook Error on row " + index + ":\n  " + stack, { row: row, mode: mode });
                        return {};
                    }
                },
                fieldHookCallback: function (values, meta) {
                    var fieldHook = _this.$fieldHooks.find(function (v) { return v.field === meta.field; });
                    if (!fieldHook) {
                        return undefined;
                    }
                    try {
                        return fieldHook.cb(values, meta);
                    }
                    catch (_a) {
                        var stack = _a.stack;
                        console.error("Flatfile Field Hook Error on field \"" + meta.field + "\":\n  " + stack, {
                            meta: meta,
                            values: values
                        });
                        return [];
                    }
                },
                stepHookCallback: function (step, payload) { return __awaiter(_this, void 0, void 0, function () {
                    var _a, stack;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!this.$stepHooks[step]) {
                                    return [2 /*return*/, undefined];
                                }
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, this.$stepHooks[step](payload)];
                            case 2: return [2 /*return*/, _b.sent()];
                            case 3:
                                _a = _b.sent();
                                stack = _a.stack;
                                console.error("Flatfile Step Hook Error on step \"" + step + "\":\n  " + stack, {
                                    payload: payload
                                });
                                return [3 /*break*/, 4];
                            case 4: return [2 /*return*/];
                        }
                    });
                }); },
                ready: function () {
                    _this.handshake.promise
                        .then(function (child) {
                        _this.$resolver(child);
                        if (_this.customer) {
                            child.setUser(_this.customer);
                        }
                    })
                        .catch(function (err) {
                        console.error(err);
                    });
                    return _this.options;
                }
            }
        });
        this.handshake.promise.catch(function (err) {
            _this.$rejecter(err);
        });
    };
    FlatfileImporter.prototype.$generateUuid = function () {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    };
    FlatfileImporter.prototype.responsePromise = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var loadResolveHandler = function (rows, meta) { return __awaiter(_this, void 0, void 0, function () {
                var results;
                return __generator(this, function (_a) {
                    results = new Results(rows, meta, this);
                    resolve(results);
                    cleanup();
                    return [2 /*return*/];
                });
            }); };
            function loadRejectHandler(err) {
                reject(err);
                cleanup();
            }
            var self = _this;
            function cleanup() {
                self.removeListener('close', loadRejectHandler);
                self.removeListener('results', loadResolveHandler);
            }
            _this.on('close', loadRejectHandler);
            _this.on('results', loadResolveHandler);
        });
    };
    FlatfileImporter.Promise = Promise;
    FlatfileImporter.MOUNT_URL = 'https://portal-2.flatfile.io/?key=:key';
    return FlatfileImporter;
}(eventemitter3_1));

registerDocumentContainsPolyfill();

/* harmony default export */ __webpack_exports__["a"] = (FlatfileImporter$1);
//# sourceMappingURL=index.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "fae3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "FlatfileButton", function() { return /* reexport */ FlatfileButton; });

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"6113ca50-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/FlatfileButton.vue?vue&type=template&id=bc2f23a2&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('button',{on:{"click":_vm.launch}},[_vm._t("default")],2)])}
var staticRenderFns = []


// CONCATENATED MODULE: ./src/components/FlatfileButton.vue?vue&type=template&id=bc2f23a2&

// EXTERNAL MODULE: ./node_modules/@flatfile/adapter/build/browser/index.js
var browser = __webpack_require__("f2ae");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/FlatfileButton.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//

/* harmony default export */ var FlatfileButtonvue_type_script_lang_js_ = ({
  name: "flatfile-button",
  props: {
    settings: {
      type: Object,
      validator: function validator(value) {
        return value && value.type && value.fields;
      }
    },
    customer: {
      type: Object,
      validator: function validator(value) {
        return value && value.userId;
      }
    },
    licenseKey: {
      type: String,
      validator: function validator(value) {
        return value && value.length;
      }
    },
    fieldHooks: Object,
    source: [String, Array],
    onCancel: Function,
    onInteractionEvent: Function,
    onBeforeFetch: Function,
    onData: Function,
    onRecordChange: Function,
    onRecordInit: Function,
    render: Function,
    preload: {
      default: true,
      type: Boolean
    },
    mountUrl: String
  },
  data: function data() {
    return {
      flatfileImporter: null,
      loaded: false,
      importerLoaded: true
    };
  },
  mounted: function mounted() {
    if (this.preload) {
      this.loadImporter();
    }
  },
  methods: {
    loadImporter: function loadImporter() {
      var _this = this;

      if (this.flatfileImporter) {
        return;
      }

      if (this.mountUrl) {
        browser["a" /* default */].setMountUrl(this.mountUrl);
      }

      var tempImporter = new browser["a" /* default */](this.licenseKey, this.settings, this.customer);

      if (this.fieldHooks) {
        for (var key in this.fieldHooks) {
          tempImporter.registerFieldHook(key, this.fieldHooks[key]);
        }
      }

      if (this.onBeforeFetch) {
        tempImporter.registerBeforeFetchCallback(this.onBeforeFetch);
      }

      if (this.onInteractionEvent) {
        tempImporter.registerInteractionEventCallback(this.onInteractionEvent);
      }

      if (this.onRecordChange || this.onRecordInit) {
        tempImporter.registerRecordHook(function (record, // : ScalarDictionaryWithCustom,
        index, // : number,
        eventType // : 'init' | 'change'
        ) {
          if (eventType === "init" && _this.onRecordInit) {
            return _this.onRecordInit(record, index);
          }

          if (eventType === "change" && _this.onRecordChange) {
            return _this.onRecordChange(record, index);
          }
        });
      }

      this.flatfileImporter = tempImporter;
      this.loaded = true;
    },
    dataHandler: function dataHandler(results) {
      var _this$onData,
          _this2 = this;

      this.flatfileImporter.displayLoader();
      (_this$onData = this.onData) === null || _this$onData === void 0 ? void 0 : _this$onData.call(this, results).then(function (optionalMessage) {
        var _this2$flatfileImport, _this2$flatfileImport2;

        return optionalMessage !== null ? (_this2$flatfileImport = _this2.flatfileImporter.current) === null || _this2$flatfileImport === void 0 ? void 0 : _this2$flatfileImport.displaySuccess(optionalMessage || undefined) : (_this2$flatfileImport2 = _this2.flatfileImporter.current) === null || _this2$flatfileImport2 === void 0 ? void 0 : _this2$flatfileImport2.close();
      }, function (error
      /*: Error | string*/
      ) {
        var _this2$flatfileImport3;

        return (_this2$flatfileImport3 = _this2.flatfileImporter.current) === null || _this2$flatfileImport3 === void 0 ? void 0 : _this2$flatfileImport3.requestCorrectionsFromUser(error instanceof Error ? error.message : error).then(_this2.dataHandler, function () {
          var _this2$onCancel;

          return (_this2$onCancel = _this2.onCancel) === null || _this2$onCancel === void 0 ? void 0 : _this2$onCancel.call(_this2);
        });
      });
    },
    launch: function launch() {
      var _this3 = this;

      this.validateInputs();

      var dataHandler = function dataHandler(results) {
        _this3.flatfileImporter.displayLoader();

        if (_this3.onData) {
          _this3.onData(results).then(function (optionalMessage) {
            _this3.flatfileImporter.displaySuccess(optionalMessage || "Success!");
          }, function (error) {
            console.error("Flatfile Error : ".concat(error));

            _this3.flatfileImporter.requestCorrectionsFromUser(error ? error.message : error).then(dataHandler, function () {
              var _this3$onCancel;

              return (_this3$onCancel = _this3.onCancel) === null || _this3$onCancel === void 0 ? void 0 : _this3$onCancel.call(_this3);
            });
          });
        } else {
          _this3.flatfileImporter.displaySuccess("Success!");
        }
      };

      if (!this.flatfileImporter) {
        if (this.preload) {
          return;
        }

        this.loadImporter();
      }

      var loadOptions = this.source ? {
        source: this.source
      } : undefined;
      this.flatfileImporter.requestDataFromUser(loadOptions).then(dataHandler, function () {
        var _this3$onCancel2;

        return (_this3$onCancel2 = _this3.onCancel) === null || _this3$onCancel2 === void 0 ? void 0 : _this3$onCancel2.call(_this3);
      });
    },
    validateInputs: function validateInputs() {
      var _this$customer, _this$settings, _this$settings2;

      if (!this.licenseKey) {
        console.error("[Error] Flatfile VueJS Adapter - licenseKey not provided!");
        this.isImporterLoaded = false;
      }

      if (!((_this$customer = this.customer) !== null && _this$customer !== void 0 && _this$customer.userId)) {
        console.error("[Error] Flatfile VueJS Adapter - customer userId not provided!");
        this.isImporterLoaded = false;
      }

      if (!((_this$settings = this.settings) !== null && _this$settings !== void 0 && _this$settings.type) || !((_this$settings2 = this.settings) !== null && _this$settings2 !== void 0 && _this$settings2.fields)) {
        console.error("[Error] Flatfile VueJS Adapter - settings { type: String, fields: Array } not provided!");
        this.isImporterLoaded = false;
      }
    }
  }
});
// CONCATENATED MODULE: ./src/components/FlatfileButton.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_FlatfileButtonvue_type_script_lang_js_ = (FlatfileButtonvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/FlatfileButton.vue





/* normalize component */

var component = normalizeComponent(
  components_FlatfileButtonvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var FlatfileButton = (component.exports);
// CONCATENATED MODULE: ./src/index.js

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib-no-default.js




/***/ })

/******/ });
});
//# sourceMappingURL=vuejs.umd.js.map